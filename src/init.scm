;; INIT
(let ((port (open-output-file "init")))
 (write '(begin
	  ;; load library "lib"
	  (load "lib")
	  ;; buttons
	  (define button1 (pin 23))
	  (define button2 (pin 24))
	  (define button3 (pin 25))
	  (set-input-pin! button1)
	  (set-input-pin! button2)
	  (set-input-pin! button3)
	  ;; leds
	  (define ledR (pin 10))
	  (define ledG (pin 9))
	  (define ledB (pin 8))
	  (set-output-pin! ledR)
	  (set-output-pin! ledG)
	  (set-output-pin! ledB)
	  ;; accelerometer
	  (define x-pin (pin 16))
	  (define y-pin (pin 17))
	  ;; color
	  (define red #xF00)
	  (define green #x0F0)
	  (define blue #x00F)
	  (define white #xFFF)
	  (define black #x000)
	  (define yellow #xFF0)
	  (define cyan #x0FF)
	  (define magenta #xF0F)
	  ;; variables/procedures
      	  (define set set-pin!)
   	  (define clear clear-pin!)
	  (define set? is-pin-set?)
	  (define fill fill-rectangle!)
	  (define width-screen 130)
	  (define height-screen 130)
	  (define (clear-screen) 
	   (fill 0 0 width-screen height-screen white))
	  (define (clear-leds)
	   (clear ledR)
	   (clear ledG)
	   (clear ledB))
	  (define (set-button?)
	   (or (set? button1) (set? button2) (set? button3)))
	  (define (set-buttons?)
	   (and (set? button1) (set? button2) (set? button3)))
	  (define (waitSkip n)
	   (if (set-button?)
	    '()
            (if (= n 0) 
	     '() 
	     (waitSkip (- n 1)))))
   ) port)
(close-output-port port))

;; MATH - Definitions
;; pi, 2pi, double->integer
(let ((port (open-output-file "math")))
 (write '(begin
	  ;; load necessary library
	  (load "init")
	  ;; some useful definitions
	  ;; random
	  (define (random a b)
	   (+ (modulo (+ (pulse_in x-pin) (pulse_in y-pin)) b) a))
	  (define (!= a b) (not (eq? a b)))
	  (define pi 3.14159)
	  (define pi/2 (/ pi 2))
	  (define pi/4 (/ pi 4))
	  (define pi/8 (/ pi 8))
	  (define pi/16 (/ pi 16))
   	  (define pi3/2 (* 3 pi/2))
	  (define pi3/4 (* 3 pi/4))
	  (define pi2 (* 2 pi))
	  ;; Get Linear function from 2 points (x1,y1) and (x2,y2)
	  (define (getLinearFunction x1 y1 x2 y2)
	   (lambda (x) (+ y1 (* (/ (- y2 y1) (- x2 x1)) (- x x1)))))
	  ;; Convert a real number which is in the scientific format (e.g. 7.5e1) into an integer (e.g. 75).
	  (define (double->integer x)
	   (let* ((s (string->list (number->string (round x))))
		  (counter 0)
		  (posPoint 0)
		  (sentence (list->string s)))
	    (define (f s count)
	     (if (null? s)
	      '()
	      (if (!= (car s) #\.)
	       (if (!= (car s) #\e)
		(cons (car s) (f (cdr s) (+ count 1)))
		(begin
		 (set! counter (+ count 1))
		 '()))
	       (begin 
		(set! posPoint count)
		(f (cdr s) (+ count 1))))))
	    (define (f1) 
	     (if (eq? counter 0)
	      1
	      (expt 10 (- (string->number (substring sentence counter (string-length sentence))) (- (- counter 2) posPoint))) ))
	    (* (string->number (list->string (f s 0))) (f1))))
   ) port)
(close-output-port port))

;; FIGURES
;; Draw/Fill rectangles, lines, circles, triangle.
(let ((port (open-output-file "figures")))
 (write '(begin
	  ;; load necessary library
	  (load "math")
	  ;; Some definitions
	  (define xCenter 65)
	  (define yCenter 65)
	  ;; draw Rectangle
	  (define (drawRectangle x y width height thickness color) 
	    (fill x y thickness height color) ;; South
	    (fill (- (+ x width) thickness) y thickness height color) ;; North
	    (fill x y width thickness color) ;; West
	    (fill x (- (+ y height) thickness) width thickness color)) ;; East
	  ;; draw Curve
	  (define (drawCurve x y radiusX radiusY thickness thetaInit thetaEnd color . args)
	   (let ((step 128))
	    (if (not (null? args))
	     (if (integer? (car args))
	      (set! step (abs (car args)))))
	    (let ((dtheta (/ pi2 step)))
	     (if (<= thetaInit thetaEnd)
	      (do ((theta thetaInit (+ theta dtheta)))
	       ((>= theta thetaEnd))
	       (fill (double->integer (+ x (* radiusX (cos theta)))) (double->integer (+ y (* radiusY (sin theta)))) thickness thickness color))
	      (begin 
	       (do ((theta thetaInit (+ theta dtheta)))
		((>= theta pi2))
		(fill (double->integer (+ x (* radiusX (cos theta)))) (double->integer (+ y (* radiusY (sin theta)))) thickness thickness color))
	       (do ((theta 0 (+ theta dtheta)))
		((>= theta thetaEnd))
		(fill (double->integer (+ x (* radiusX (cos theta)))) (double->integer (+ y (* radiusY (sin theta)))) thickness thickness color)))))))
	  ;; draw Line
	  (define (drawLine x1 y1 x2 y2 thickness color)
	   (let ((dx (- x2 x1))
		 (dy (- y2 y1)))
	    (if (eq? dx 0)
	     (if (> y2 y1)
	      (fill x1 y1 thickness dy color)
	      (fill x1 y2 thickness (- dy) color))
	     (if (eq? dy 0)
	      (if (> x2 x1)
	       (fill x1 y1 dx thickness color)
	       (fill x2 y1 (- dx) thickness color))
	      (let ((m (/ dy dx)))
	       (if (and (<= m -1) (>= m 1))
		(if (<= x1 x2)
		 (do ((x x1 (+ x 1)) (y y1))
		  ((> x x2))
		  (fill x (round y) thickness thickness color)
		  (set! y (+ y1 (* m (- x x1)))))
		 (do ((x x1 (- x 1)) (y y1))
		  ((< x x2))
		  (fill x (round y) thickness thickness color)
		  (set! y (+ y1 (* m (- x x1))))))
		(if (<= y1 y2)
		 (do ((y y1 (+ y 1)) (x x1))
		  ((> y y2))
		  (fill (round x) y thickness thickness color)
		  (set! x (+ x1 (* (/ 1 m) (- y y1)))))
		 (do ((y y1 (- y 1)) (x x1))
		  ((< y y2))
		  (fill (round x) y thickness thickness color)
		  (set! x (+ x1 (* (/ 1 m) (- y y1))))))))))))
	  ;; draw Triangle
	  (define (drawTriangle x1 y1 x2 y2 x3 y3 thickness color)
	   (drawLine x1 y1 x2 y2 thickness color)
	   (drawLine x2 y2 x3 y3 thickness color)
	   (drawLine x3 y3 x1 y1 thickness color))
	  ;; draw Ellipse
	  (define (drawEllipse x y radiusX radiusY thickness color . args)
	   (if (null? args)
		(drawCurve x y radiusX radiusY thickness 0 pi2 color)
		(drawCurve x y radiusX radiusY thickness 0 pi2 color (car args))))
      	  ;; draw Circle
	  (define (drawCircle x y radius thickness color . args)
	    (if (null? args)
	     (drawCurve x y radius radius thickness 0 pi2 color)
	     (drawCurve x y radius radius thickness 0 pi2 color (car args))))
	  ;; fill Circle
	  (define (fillCircle x y radius color . args)
	   (let ((step 128))
	    (if (not (null? args))
	     (if (integer? (car args))
	      (set! step (abs (car args)))))
	    (let ((dtheta (/ pi2 step)))
	     (do ((theta 0 (+ theta dtheta)))
	      ((>= theta pi))
	      (fill (+ x (double->integer (* radius (cos theta)))) (- y (abs (double->integer (* radius (sin theta))))) 2 (+ (* 2 (double->integer (* radius (sin theta)))) 1) color)))))
	  ;; fill Ellipse
	  (define (fillEllipse x y radiusX radiusY color . args)
	   (let ((step 128))
	    (if (not (null? args))
	     (if (integer? (car args))
	      (set! step (abs (car args)))))
	    (let ((dtheta (/ pi2 step)))
	     (do ((theta 0 (+ theta dtheta)))
	      ((>= theta pi))
	      (fill (+ x (double->integer (* radiusX (cos theta)))) (- y (abs (double->integer (* radiusY (sin theta))))) 2 (+ (* 2 (double->integer (* radiusY (sin theta)))) 1) color)))))
	  ;; Draw Cursor pointing to the left
	  (define (drawCursorL x y height color)
	   (let ((yf (+ y height))
		 (y/2 (+ y (round (/ height 2))))
		 (width 1))
	    (do ( (i yf (- i 1)) )
	     ((<= i y/2))
	     (fill x i width 1 color)
	     (set! width (+ width 1)))
	    (do ( (i y/2 (- i 1)) )
	     ((< i y))
	     (fill x i width 1 color)
	     (set! width (- width 1)))))
	  ;; Draw Cursor pointing to the right
	  (define (drawCursorR x y height color)
	   (let ((yf (+ y height))
		 (y/2 (+ y (round (/ height 2))))
		 (width 1))
	    (do ( (i yf (- i 1)) )
	     ((<= i y/2))
	     (fill (- (+ x 1) width) i width 1 color)
	     (set! width (+ width 1)))
	    (do ( (i y/2 (- i 1)) )
	     ((< i y))
	     (fill (- (+ x 1) width) i width 1 color)
	     (set! width (- width 1)))))
      	  ;; Draw Cursor pointing up
	  (define (drawCursorU x y width color)
	   (let ((xf (- x width))
		 (x/2 (- x (round (/ width 2))))
		 (height 1))
	    (do ( (i x (- i 1)) )
	     ((<= i x/2))
	     (fill i y 1 height color)
	     (set! height (+ height 1)))
	    (do ( (i x/2 (- i 1)) )
	     ((< i xf))
	     (fill i y 1 height color)
	     (set! height (- height 1)))))
	  ;; Draw Cursor pointing down
	  (define (drawCursorD x y width color)
	   (let ((xf (- x width))
		 (x/2 (- x (round (/ width 2))))
		 (height 1))
	    (do ( (i x (- i 1)) )
	     ((<= i x/2))
	     (fill i (- y height) 1 height color)
	     (set! height (+ height 1)))
	    (do ( (i x/2 (- i 1)) )
	     ((< i xf))
	     (fill i (- y height) 1 height color)
	     (set! height (- height 1)))))
   ) port)
(close-output-port port))

;; Draw Characters/Integers
(let ((port (open-output-file "char")))
 (write '(begin
	  ;; load necessary library
	  (load "figures")
      	  ;; Draw Natural Numbers
	  (define (drawInt n x y size color)
	   (let* ((size/2 (round (/ size 2)))
		  (size/3 (round (/ size 3)))
		  (size/4 (round (/ size 4)))
		  (xf (- x size/2))
		  (yf (+ y size))
		  (xm (- x size/4))
		  (ym (+ y size/2)))
	    ;; 0
	    (define (draw0)
	     (drawLine x y x yf 1 color)
	     (drawLine x yf xf yf 1 color)
	     (drawLine xf yf xf y 1 color)
	     (drawLine xf y x y 1 color)
	     (drawLine x y xf yf 1 color)
	     size/2)
	    ;; 1
	    (define (draw1)
	     (drawLine x (- yf size/4) xm yf 1 color)
	     (drawLine xm yf xm y 1 color)
	     (drawLine x y xf y 1 color)
	     size/2)
	    ;; 2
	    (define (draw2)
	     (drawLine x yf xf yf 1 color)
	     (drawLine xf yf xf ym 1 color)
	     (drawLine xf ym x ym 1 color)
	     (drawLine x ym x y 1 color)
	     (drawLine x y xf y 1 color)
	     size/2)
	    ;; 3
	    (define (draw3)
	     (drawLine x yf xf yf 1 color)
	     (drawLine x ym xf ym 1 color)
	     (drawLine x y xf y 1 color)
	     (drawLine xf yf xf y 1 color)
	     size/2)
	    ;; 4
	    (define (draw4)
	     (drawLine x yf x ym 1 color)
	     (drawLine x ym xf ym 1 color)
	     (drawLine xf yf xf y 1 color)
	     size/2)
	    ;; 5
	    (define (draw5)
	     (drawLine xf yf x yf 1 color)
	     (drawLine x yf x ym 1 color)
	     (drawLine x ym xf ym 1 color)
	     (drawLine xf ym xf y 1 color)
	     (drawLine xf y x y 1 color)
	     size/2)
	    ;; 6
	    (define (draw6)
	     (drawLine xf yf x yf 1 color)
	     (drawLine x yf x y 1 color)
	     (drawLine x y xf y 1 color)
	     (drawLine xf y xf ym 1 color)
	     (drawLine xf ym x ym 1 color)
	     size/2)
	    ;; 7
	    (define (draw7)
	     (drawLine x yf xf yf 1 color)
	     (drawLine xf yf x y 1 color)
	     size/2)
	    ;; 8
	    (define (draw8)
	     (drawLine x y x yf 1 color)
	     (drawLine x yf xf yf 1 color)
	     (drawLine xf yf xf y 1 color)
	     (drawLine xf y x y 1 color)
	     (drawLine x ym xf ym 1 color)
	     size/2)
	    ;; 9
	    (define (draw9)
	     (drawLine xf ym x ym 1 color)
	     (drawLine x ym x yf 1 color)
	     (drawLine x yf xf yf 1 color)
	     (drawLine xf yf xf y 1 color)
	     (drawLine xf y x y 1 color)
	     size/2)
	   (if (and (integer? n) (>= n 0) (<= n 9))
	    (cond 
	     ((eq? n 0) (draw0))
	     ((eq? n 1) (draw1))
	     ((eq? n 2) (draw2))
	     ((eq? n 3) (draw3))
	     ((eq? n 4) (draw4))
	     ((eq? n 5) (draw5))
	     ((eq? n 6) (draw6))
	     ((eq? n 7) (draw7))
	     ((eq? n 8) (draw8))
	     ((eq? n 9) (draw9))))))
      	  ;; Draw Characters
	  (define (drawChar c x y size color)
	   (let* ((ch (char-upcase c))
		  (size/2 (round (/ size 2)))
		  (size/3 (round (/ size 3)))
		  (size/4 (round (/ size 4)))
		  (size/8 (round (/ size 8)))
		  (xf (- x size/2))
		  (yf (+ y size))
		  (xm (- x size/4))
		  (ym (+ y size/2)))
	    ;; A
	    (define (drawA)
	     (drawLine x y x yf 1 color)
	     (drawLine x yf xf yf 1 color)
	     (drawLine xf yf xf y 1 color)
	     (drawLine x ym xf ym 1 color)
	     size/2)
	    ;; B (curvy)
	    (define (drawBc)
	     (drawLine x y x yf 1 color)
	     (drawCurve x (- yf size/4) size/2 size/4 1 pi/2 pi3/2 color)
	     (drawCurve x (+ y size/4) size/2 size/4 1 pi/2 pi3/2 color)
	     size/2)
	    ;; B
	    (define (drawB)
	     (drawLine x y x yf 1 color)
	     (drawLine x yf xm yf 1 color)
	     (drawLine xm yf xm ym 1 color)
	     (drawLine x ym xf ym 1 color)
	     (drawLine xf ym xf y 1 color)
	     (drawLine xf y x y 1 color)
	     size/2)
	    ;; C
	    (define (drawC)
      	     (drawLine xf yf x yf 1 color)
	     (drawLine x yf x y 1 color)
	     (drawLine x y xf y 1 color)
	     size/2)
	    ;; D (curvy)
	    (define (drawDc)
      	     (drawLine x y x yf 1 color)
	     (drawCurve x (- yf size/2) size/2 size/2 1 pi/2 pi3/2 color)
	     size/2)
	    ;; D
	    (define (drawD)
	     (let ((y1 (- yf size/4))
		   (y2 (+ y size/4)))
	      (drawLine x y x yf 1 color)
	      (drawLine x yf xf y1 1 color)
	      (drawLine xf y1 xf y2 1 color)
	      (drawLine x y xf y2 1 color)
	      size/2))
	    ;; E
	    (define (drawE)
      	     (drawLine xf yf x yf 1 color)
	     (drawLine xf ym x ym 1 color)
	     (drawLine xf y x y 1 color)
	     (drawLine x yf x y 1 color)
	     size/2)
	  ;; F
	  (define (drawF)
	   (let ((y1 (- yf size/3)))
	    (drawLine xf yf x yf 1 color)
	    (drawLine xf y1 x y1 1 color)
	    (drawLine x yf x y 1 color)
	    size/2))
	  ;; G   
	  (define (drawG)
      	    (drawLine xf yf x yf 1 color)
	    (drawLine x yf x y 1 color)
	    (drawLine x y xf y 1 color)
	    (drawLine xf y xf ym 1 color)
	    (drawLine xf ym xm ym 1 color)
	    size/2)
	  ;; H
	  (define (drawH)
      	    (drawLine x y x yf 1 color)
	    (drawLine x ym xf ym 1 color)
	    (drawLine xf y xf yf 1 color)
	    size/2)
	  ;; I
	  (define (drawI)
      	    (drawLine x yf xf yf 1 color)
	    (drawLine x y xf y 1 color)
	    (drawLine xm y xm yf 1 color)
	    size/2)
	  ;; J
	  (define (drawJ)
	   (let ((x1 (+ xf size/8)))
	    (drawLine x yf xf yf 1 color)
	    (drawLine x1 yf x1 y 1 color)
	    (drawLine x1 y x y 1 color)
	    (drawLine x y x ym 1 color)
	    size/2))
	  ;; K
	  (define (drawK)
      	    (drawLine x y x yf 1 color)
	    (drawLine x (- ym 2) xf yf 1 color)
	    (drawLine x (+ ym 2) xf y 1 color)
	    size/2)
	  ;; L
	  (define (drawL)
	    (drawLine x yf x y 1 color)
	    (drawLine x y xf y 1 color)
	    size/2)
	  ;; M
	  (define (drawM)
	   (let* ((width (* 2 size/3))
		  (width/2 size/3)
		  (x1 (- x width))
		  (x2 (- x width/2)))
	    (drawLine x y x yf 1 color)
	    (drawLine x yf x2 ym 1 color)
	    (drawLine x1 y x1 yf 1 color)
	    (drawLine x1 yf x2 ym 1 color)
	    width))
	  ;; N
	  (define (drawN)
      	    (drawLine x y x yf 1 color)
	    (drawLine x yf xf y 1 color)
	    (drawLine xf y xf yf 1 color)
	    size/2)
	  ;; O (curvy)
	  (define (drawOc)
      	    (drawCurve (- x size/3) (+ y size/2) size/3 size/2 1 0 pi2 color)
	    (* 2 size/3))
	  ;; O
	  (define (drawO)
	   (drawLine x y x yf 1 color)
	   (drawLine x yf xf yf 1 color)
	   (drawLine xf yf xf y 1 color)
	   (drawLine xf y x y 1 color)
	   size/2)
	  ;; P (curvy)
	  (define (drawPc)
      	    (drawLine x y x yf 1 color)
	    (drawCurve x (- yf size/3) size/2 size/3 1 pi/2 pi3/2 color)
	    size/2)
	  ;; P
	  (define (drawP)
	   (drawLine x y x yf 1 color)
	   (drawLine x yf xf yf 1 color)
	   (drawLine xf yf xf ym 1 color)
	   (drawLine xf ym x ym 1 color)
	   size/2)
      	  ;; Q (curvy)
	  (define (drawQc)
	   (let* ((width (+ (* 2 size/3) 2))
      		  (x1 (- x width)))
	    (drawCurve (- x size/3) (+ y size/2) size/3 size/2 1 0 pi2 color)
	    (drawLine (+ x1 size/3) (+ y size/4) x1 (- y 1) 1 color)
	    width))
	  ;; Q
	  (define (drawQ)
	   (drawO)
	   (drawLine xm ym (- xf 2) (- y 2) 1 color)
	   size/2)
	  ;; R (curvy)
	  (define (drawRc)
	   (let* ((width (* 2 size/3))
		  (x1 (- x width)))
	    (drawLine x y x yf 1 color)
	    (drawCurve x (- yf size/3) size/2 size/3 1 pi/2 pi3/2 color)
	    (drawLine (- x size/3) (- yf width) x1 y 1 color)
	    width))
	  ;; R
	  (define (drawR)
	   (drawP)
	   (drawLine x (+ ym 1) xf y 1 color)
	   size/2)
	  ;; S (curvy)
	  (define (drawSc)
	   (let ((x (- x size/4))
		 (y (+ y size/4)))
	    (drawCurve x y size/4 size/4 1 pi/2 pi2 color)
	    (drawCurve x (+ y size/2) size/4 size/4 1 pi3/2 pi color)
	    size/2))
	  ;; S
	  (define (drawS)
	    (drawLine xf (- yf size/4) xf yf 1 color)
	    (drawLine xf yf x yf 1 color)
	    (drawLine x yf x ym 1 color)
	    (drawLine x ym xf ym 1 color)
	    (drawLine xf ym xf y 1 color)
	    (drawLine xf y x y 1 color)
	    (drawLine x y x (+ y size/4) 1 color)
	    size/2)
	  ;; T
	  (define (drawT)
      	    (drawLine x yf xf yf 1 color)
	    (drawLine xm y xm yf 1 color)
	    size/2)
	  ;; U
	  (define (drawU)
      	    (drawLine x yf x y 1 color)
	    (drawLine x y xf y 1 color)
	    (drawLine xf y xf yf 1 color)
	    size/2)
	  ;; V
	  (define (drawV)
	   (let* ((width (* 2 size/3))
		  (x1 (- x width))
		  (x2 (- x size/3)))
	    (drawLine x yf x2 y 1 color)
	    (drawLine x1 yf x2 y 1 color)
	    width))
	  ;; W
	  (define (drawW)
	   (let* ((width (* 2 size/3))
		  (x1 (- x width))
		  (x2 (- x size/3)))
	    (drawLine x yf x y 1 color)
	    (drawLine x y x2 ym 1 color)
	    (drawLine x1 yf x1 y 1 color)
	    (drawLine x1 y x2 ym 1 color)
	    width))
	  ;; X
	  (define (drawX)
	   (let* ((width (* 2 size/3))
		  (x1 (- x width)))
	    (drawLine x y x1 yf 1 color)
	    (drawLine x1 y x yf 1 color)
	    width))
	  ;; Y
	  (define (drawY)
	   (let* ((width (* 2 size/3))
		  (x1 (- x width))
		  (x2 (- x size/3)))
	    (drawLine x yf x2 ym 1 color)
	    (drawLine x1 yf x2 ym 1 color)
	    (drawLine x2 ym x2 y 1 color)
	    width))
	  ;; Z
	  (define (drawZ)
      	    (drawLine x yf xf yf 1 color)
	    (drawLine xf yf x y 1 color)
	    (drawLine x y xf y 1 color)
	    size/2)
	    (cond 
	     ((eq? ch #\A) (drawA))
	     ((eq? ch #\B) (drawB))
	     ((eq? ch #\C) (drawC))
	     ((eq? ch #\D) (drawD))
	     ((eq? ch #\E) (drawE))
	     ((eq? ch #\F) (drawF))
	     ((eq? ch #\G) (drawG))
	     ((eq? ch #\H) (drawH))
	     ((eq? ch #\I) (drawI))
	     ((eq? ch #\J) (drawJ))
	     ((eq? ch #\K) (drawK))
	     ((eq? ch #\L) (drawL))
	     ((eq? ch #\M) (drawM))
	     ((eq? ch #\N) (drawN))
	     ((eq? ch #\O) (drawO))
	     ((eq? ch #\P) (drawP))
	     ((eq? ch #\Q) (drawQ))
	     ((eq? ch #\R) (drawR))
	     ((eq? ch #\S) (drawS))
	     ((eq? ch #\T) (drawT))
	     ((eq? ch #\U) (drawU))
	     ((eq? ch #\V) (drawV))
	     ((eq? ch #\W) (drawW))
	     ((eq? ch #\X) (drawX))
	     ((eq? ch #\Y) (drawY))
	     ((eq? ch #\Z) (drawZ)))))
	  ;; Special Characters
	  (define (drawSpecialChar c x y size color)
	   (let* ((size/2 (round (/ size 2)))
		  (size/3 (round (/ size 3)))
		  (size/4 (round (/ size 4)))
		  (size/8 (round (/ size 8)))
		  (xf (- x size/2))
		  (yf (+ y size))
		  (xm (- x size/4))
		  (ym (+ y size/2)))
	    (define (draw.)
	     (fill x y 1 2 black)
	     2)
	    (define (drawApostrophe)
	     (fill x yf 1 3 black)
	     2)
	    (define (draw?)
	     (drawLine x (- yf size/4) x yf 1 color)
	     (drawLine x yf xf yf 1 color)
	     (drawLine xf yf xf ym 1 color)
	     (drawLine xf ym xm ym 1 color)
	     (drawLine xm ym xm (+ y 3) 1 color)
	     (fill xm y 1 2 color)
	     size/2)
	    (define (draw!)
	     (drawLine x yf x (+ y 3) 1 color)
	     (draw.))
	    (define (draw/)
	     (drawLine x y xf yf 1 color)
	     size/2)
	    (define (draw-)
	     (drawLine x ym xf ym 1 color)
	     size/2)
	    (define (draw+)
	     (drawLine x ym xf ym 1 color)
	     (drawLine xm y xm yf 1 color)
	     size/2)
	    (define (draw:)
	     (fill x (- yf 2) 1 2 color)
	     (fill x (+ y 2) 1 2 color)
	     2)
	    (define (drawComma)
	     (drawLine x y (+ x 3) (- y 3) 1 color)
	     2)
	    (define (drawSemiColon)
	     (fill x (- yf 2) 1 2 color)
	     (drawComma))
	    (cond 
	     ((eq? c #\.) (draw.))
	     ((eq? c #\') (drawApostrophe))
	     ((eq? c #\?) (draw?))
	     ((eq? c #\!) (draw!))
	     ((eq? c #\/) (draw/))
	     ((eq? c #\-) (draw-))
	     ((eq? c #\+) (draw+))
	     ((eq? c #\:) (draw:))
	     ((eq? c #\,) (drawComma))
	     ((eq? c #\;) (drawSemiColon))
	     (else -4))))
	  ;; Print
	  (define (print str x y size color)
	   (let ((s (string->list str))
		 (x0 x))
	    (define (p s)
	     (if (null? s)
	      'done
	      (let ((c (car s)))
	       (cond
		((char-alphabetic? c) (set! x (- x (drawChar c x y size color) 4)))
		((char-numeric? c) (set! x (- x (drawInt (- (char->integer c) 48) x y size color) 4)))
		((eq? c #\space) (set! x (- x (round (/ size 2)))))
		(else (set! x (- x (drawSpecialChar c x y size color) 4))))
	       (if (< x size)
		(begin 
		 (set! x x0)
		 (if (> y (+ size 4))
		  (begin
		   (set! y (- y (+ size 4)))
		   (p (cdr s)))))
		 (p (cdr s))))))
	    (p s)))
   ) port)
(close-output-port port))

;; Menu
(let ((port (open-output-file "menu")))
 (write '(begin
	  ;; load necessary library
	  (load "char")
	  ;; Starting Menu
	  (define (startingMenu)
	   (let* ((x 90)
		  (y0 70)
		  (xCursor 105)
		  (yCursor 0)
		  (size 12)
      		  (offset (+ size 8))
		  (y (list y0 (- y0 offset)))
		  (sizeListY (length y))
		  (color black))
	    (clear-screen)
	    (print "tamagotchi" 115 100 12 black)
	    (print "1.play" x (list-ref y 0) size color)
	    (print "2.exit" x (list-ref y 1) size color)
      	    (drawCursorR xCursor (list-ref y yCursor) 10 color)
	    (define (action)
	     (cond 
	      ((set? button1) 
	       (fill (+ x 2) (list-ref y yCursor) (- 130 x) 11 white)
	       (if (eq? (- yCursor 1) -1)
		(set! yCursor (- sizeListY 1))
	        (set! yCursor (- yCursor 1)))
	       (drawCursorR xCursor (list-ref y yCursor) 10 color)
	       (wait 4000)
	       (action))
	      ((set? button3) 
	       (fill (+ x 2) (list-ref y yCursor) (- 130 x) 11 white)
	       (set! yCursor (modulo (+ yCursor 1) sizeListY))
	       (drawCursorR xCursor (list-ref y yCursor) 10 color)
	       (wait 4000)
	       (action))
	      ((set? button2)
	       (cond 
		((eq? yCursor 0) 'play)
	        ((eq? yCursor 1) 'exit)))
	      (else (action))))
	  (action)))

	  ;; Menu (during the game)
	  (define (menu)
	   (let* ((x 110)
		  (xCursor 120)
		  (yCursor 0)
		  (size 12)
		  (y0 110)
		  (offset (+ size 4))
		  (y (list y0 (- y0 offset) (- y0 (* 2 offset)) (- y0 (* 3 offset)) (- y0 (* 4 offset)) (- y0 (* 5 offset)) (- y0 (* 6 offset))))
		  (sizeListY (length y))
		  (color black))
	   (clear-screen)
	   (print "1.feed" x (list-ref y 0) size color)
	   (print "2.sleep" x (list-ref y 1) size color)
	   (print "3.play" x (list-ref y 2) size color)
	   (print "4.clean/wc" x (list-ref y 3) size color)
	   (print "5.drug" x (list-ref y 4) size color)
	   (print "6.about" x (list-ref y 5) size color)
	   (print "7.exit" x (list-ref y 6) size color)
	   (drawCursorR xCursor (list-ref y yCursor) 10 color)
	   (define (action)
	    (cond 
	     ((set? button1) 
	      (fill (+ x 2) (list-ref y yCursor) (- 130 x) 11 white)
	      (if (eq? (- yCursor 1) -1)
	       (set! yCursor (- sizeListY 1))
	       (set! yCursor (- yCursor 1)))
	      (drawCursorR xCursor (list-ref y yCursor) 10 color)
	      (wait 4000)
	      (action))
	     ((set? button3) 
	      (fill (+ x 2) (list-ref y yCursor) (- 130 x) 11 white)
	      (set! yCursor (modulo (+ yCursor 1) sizeListY))
	      (drawCursorR xCursor (list-ref y yCursor) 10 color)
	      (wait 4000)
	      (action))
	     ((set? button2)
	      (cond 
	       ((eq? yCursor 0) (display "feed") 'feed)
	       ((eq? yCursor 1) (display "sleep") 'sleep)
	       ((eq? yCursor 2) (display "play") 'play)
	       ((eq? yCursor 3) (display "clean") 'clean)
	       ((eq? yCursor 4) (display "drug") 'drug)
	       ((eq? yCursor 5) (display "about") 'about)
	       ((eq? yCursor 6) (display "exit") 'exit)))
	     (else (action))))
	    (action)))

	  ;; aboutMenu
	  (define (aboutMenu monster)
	   (if (monster 'isAMonster?)
	    (begin
	     (clear-screen)
	     (let ((life (round (/ (monster 'getLife) 10))))
	      (fill (- 110 life) 110 life 5 yellow))
	     (fill (- 110 (monster 'getHealth)) 95 (monster 'getHealth) 5 blue)
	     (fill (- 110 (monster 'getHappiness)) 80 (monster 'getHappiness) 5 red)
	     (fill (+ 10 (monster 'getHunger)) 65 (- 100 (monster 'getHunger)) 5 green)
	     (fill (- 110 (monster 'getAwakeness)) 50 (monster 'getAwakeness) 5 magenta)
	     (fill (- 110 (monster 'getSubmissiveness)) 35 (monster 'getSubmissiveness) 5 cyan)
	     (fill (- 110 (monster 'getCleanliness)) 20 (monster 'getCleanliness) 5 black)))
	    (define (loop)
	     (if (set-button?) 'exit (loop)))
	    (loop))

	  ;; Feed Menu
	  (define (feedMenu monster)
	   ;; Draw meal
	   (define (drawMeal x y)
	    (let ((radius 5)
		  (color black))
	     ;; fork
	     (drawLine (+ x radius 10) (- y radius 1) (+ x radius 10) (+ y radius) 1 color)
	     (drawLine (+ x radius 13) (+ y (- radius 1)) (+ x radius 8) (+ y (- radius 1)) 1 color)
	     (drawLine (+ x radius 13) (+ y (- radius 1)) (+ x radius 13) (+ y radius 3) 1 color)
	     (drawLine (+ x radius 8) (+ y (- radius 1)) (+ x radius 8) (+ y radius 3) 1 color)
	     ;; dish
	     (drawEllipse x y (+ radius 7) (+ radius 4) 1 color)
	     (drawEllipse x y (+ radius 3) radius 1 color)
	     ;; glass
	     (drawLine (- x radius 4) (+ y radius 2) (- x radius 8) (+ y radius 2) 1 color)
	     (drawLine (- x radius 5) (+ y radius 2) (- x radius 5) (+ y radius 5) 1 color)
	     (drawLine (- x radius 5) (+ y radius 5) (- x radius) (+ y radius 10) 1 color)
	     (drawLine (- x radius) (+ y radius 10) (- x radius 10) (+ y radius 10) 1 color)
	     (drawLine (- x radius 5) (+ y radius 5) (- x radius 10) (+ y radius 10) 1 color)))

	   ;; Draw snack
	   (define (drawSnack x y color)
	    (let ((radius 5))
	     (drawCursorR (+ x 12) (- y radius) (* 2 radius) color)
	     (fillCircle x y radius color)
	     (drawCursorL (- x 11) (- y radius) (* 2 radius) color)))

	   (let* ((x (list 115 25 70))
		  (y (list 45 45 22)) ;; or 7 (if up)
		  (cursor 0))
	    ;; drawings
	    (drawMeal 110 25)
	    (drawSnack 25 30 blue)
	    (drawSnack 15 20 red)
	    (print "exit" 80 4 10 black)
	    (drawCursorD (list-ref x cursor) (list-ref y cursor) 10 black)
	    ;; action
	    (define (action)
	     (cond 
	      ((set? button1)
	       (drawCursorD (list-ref x cursor) (list-ref y cursor) 10 white)
	       (if (eq? (- cursor 1) -1)
		(set! cursor 2)
		(set! cursor (- cursor 1)))
	       (drawCursorD (list-ref x cursor) (list-ref y cursor) 10 black)
	       (wait 4000)
	       (action))
	      ((set? button3)
	       (drawCursorD (list-ref x cursor) (list-ref y cursor) 10 white)
	       (set! cursor (modulo (+ cursor 1) 3))
	       (drawCursorD (list-ref x cursor) (list-ref y cursor) 10 black)
	       (wait 4000)
	       (action))
	      ((set? button2)
	       (cond 
		((eq? cursor 0) 
		 (if (monster 'isAMonster?) (begin ((monster 'feed) 'meal) (wait 4000)))
		 (action))
		((eq? cursor 1) 
		 (if (monster 'isAMonster?) (begin ((monster 'feed) 'snack) (wait 4000)))
		 (action))
		((eq? cursor 2) 
		 (drawCursorD (list-ref x cursor) (list-ref y cursor) 10 white)
		 (fill 95 14 35 28 white)
		 (fill 0 0 40 40 white)
		 (fill 0 0 130 30 white)
		 'done) ))
	      (else (action))))
	    (action)))

	  ;; Drugs Menu
	  (define (drugMenu monster)
	   (define (drawPills x y color)
	    (let ((radius 5))
      	     (fillCircle x y radius color)))
	   ;; Draw flask
	   (define (drawFlask x y)
	    (let ((width 16))
	     (drawLine x y (- x width) y 1 black)
	     (drawLine x y (- x 6) (+ y 8) 1 black)
	     (drawLine (- x width) y (- x (- width 6)) (+ y 8) 1 black)
	     (drawLine (- x 5) (+ y 8) (- x 5) (+ y 16) 1 black)
	     (drawLine (- x (- width 6)) (+ y 8) (- x (- width 6)) (+ y 16) 1 black)))

	   (let* ((x (list 115 30))
		  (y 34) ;; or 7 (if up)
		  (cursor 0))
	    ;; drawings
	    (drawPills 115 20 green)
	    (drawPills 105 10 blue)
      	    (print "exit" 42 10 10 black)
	    (drawCursorD (list-ref x cursor) y 10 black)
	    ;; action
	    (define (action)
	     (cond 
	      ((set? button1)
	       (drawCursorD (list-ref x cursor) y 10 white)
	       (if (eq? (- cursor 1) -1)
		(set! cursor 1)
		(set! cursor (- cursor 1)))
	       (drawCursorD (list-ref x cursor) y 10 black)
	       (wait 4000)
	       (action))
	      ((set? button3)
	       (drawCursorD (list-ref x cursor) y 10 white)
	       (set! cursor (modulo (+ cursor 1) 2))
	       (drawCursorD (list-ref x cursor) y 10 black)
	       (wait 4000)
	       (action))
	      ((set? button2)
	       (cond 
		((eq? cursor 0) 
		 (if (monster 'isAMonster?) (begin (monster 'giveDrugs) (wait 4000)))
		 (action))
      		((eq? cursor 1) 
		 (drawCursorD (list-ref x cursor) y 10 white)
      		 (fill 0 0 130 30 white)
		 'done) ))
	      (else (action))))
	    (action)))
   ) port)
(close-output-port port))

;; Games
(let ((port (open-output-file "games")))
 (write '(begin
	  ;; load necessary library
	  (load "char")
	  ;; Game guessing
	  (define (guessing-game monster)
	   (clear-leds)
	   (clear-screen)
	   (print "guess" 90 100 12 black)
	   (print "you: " 120 70 12 black)
	   (print "vs" 75 50 12 black)
	   (print "pet: " 120 30 12 black)
	   (define (playAgain?)
	    (if (set? button1)
	     (begin
	      (clear-leds)
	      (fill 0 68 82 20 white)
	      (fill 0 28 82 20 white)
	      (fill 0 0 120 28 white)
	      (wait 4000)
	      (game))
	     (if (not (or (set? button2) (set? button3)))
	      (playAgain?)
	      (begin
	       (clear-leds)
	       (clear-screen)))))
	   (define (game)
	    (let ((b1 (set? button1))
		  (b2 (set? button2))
		  (b3 (set? button3))
		  (r 0))
	     (if (or b1 b2 b3)
	      (begin 
	       (set! r (random 1 3))
	       (cond 
		(b1 (print "blue" 80 70 12 blue))
		(b2 (print "green" 80 70 12 green))
		(b3 (print "red" 80 70 12 red)))
	       (cond 
		((eq? r 1) (set ledB) (print "blue" 80 30 12 blue))
		((eq? r 2) (set ledG) (print "green" 80 30 12 green))
		((eq? r 3) (set ledR) (print "red" 80 30 12 red)))
	       (cond 
		(b1 (cond
		     ((eq? r 1) (print "You win!" 100 10 12 black) (monster 'play))
		     ((eq? r 2) (print "You fail!" 105 10 12 black))
		     ((eq? r 3) (print "You fail!" 105 10 12 black))))
		(b2 (cond
		     ((eq? r 1) (print "You fail!" 105 10 12 black))
		     ((eq? r 2) (print "You win!" 100 10 12 black) (monster 'play))
		     ((eq? r 3) (print "You fail!" 105 10 12 black))))
		(b3 (cond
		     ((eq? r 1) (print "You fail!" 105 10 12 black))
		     ((eq? r 2) (print "You fail!" 105 10 12 black))
		     ((eq? r 3) (print "You win!" 100 10 12 black) (monster 'play)))))
	       (playAgain?))
	      (game))))
	    (game))
	  ;; game rock-paper-scissor
      	  (define (rock-paper-scissor monster)
	   (clear-leds)
	   (clear-screen)
	   (print "rock-paper-scissor" 120 110 12 black)
	   (print "you: " 120 70 12 black)
	   (print "vs" 75 50 12 black)
	   (print "pet: " 120 30 12 black)
	   (define (playAgain?)
	    (if (set? button1)
	     (begin
	      (clear-leds)
	      (fill 0 68 82 20 white)
	      (fill 0 28 82 20 white)
	      (fill 0 0 120 28 white)
	      (wait 4000)
	      (game))
	     (if (not (or (set? button2) (set? button3)))
	      (playAgain?)
	      (begin 
	       (clear-leds)
	       (clear-screen)))))
	   (define (game)
	    (let ((b1 (set? button1))
		  (b2 (set? button2))
		  (b3 (set? button3))
		  (r 0))
	     (if (or b1 b2 b3)
	      (begin 
	       (set! r (random 1 3))
	       (cond 
		(b1 (print "rock" 80 70 12 black))
		(b2 (print "paper" 80 70 12 black))
		(b3 (print "scissor" 80 70 12 black)))
	       (cond 
		((eq? r 1) (set ledB) (print "rock" 80 30 12 black))
		((eq? r 2) (set ledG) (print "paper" 80 30 12 black))
		((eq? r 3) (set ledR) (print "scissor" 80 30 12 black)))
	      (cond 
	       (b1 (cond
		    ((eq? r 1) (print "draw!" 85 10 12 black) (monster 'play))
		    ((eq? r 2) (print "You fail!" 105 10 12 black))
		    ((eq? r 3) (print "You win!" 100 10 12 black) (monster 'play))))
	       (b2 (cond
		    ((eq? r 1) (print "You win!" 100 10 12 black) (monster 'play))
		    ((eq? r 2) (print "draw!" 85 10 12 black) (monster 'play))
		    ((eq? r 3) (print "You fail!" 105 10 12 black))))
	       (b3 (cond
		    ((eq? r 1) (print "You fail!" 105 10 12 black))
		    ((eq? r 2) (print "You win!" 100 10 12 black) (monster 'play))
		    ((eq? r 3) (print "draw!" 85 10 12 black) (monster 'play)))))
	      (playAgain?))
	      (game))))
	   (game))
	  ;; Game menu
	  (define (gameMenu yCursor monster)
	   (let* ((x 110)
		  (xCursor 120)
		  (size 12)
		  (y0 110)
		  (offset (+ size 4))
		  (y (list y0 (- y0 offset) (- y0 (* 3 offset)))) ;; (- y0 (* 5 offset))))
		  (sizeListY (length y))
		  (color black))
	    (clear-screen)
	    (print "1.guessing" x (list-ref y 0) size color)
	    (print "2.rock-paper-scissor" x (list-ref y 1) size color)
	    ;;(print "3.tic-tac-toe" x (list-ref y 2) size color)
	    (print "3.exit" x (list-ref y 2) size color)
	    (drawCursorR xCursor (list-ref y yCursor) 10 color)
      	    (define (playGame game)
      	     (game monster)
	     (gameMenu yCursor monster))
	    (define (action)
	     (cond 
	      ((set? button1) 
	       (fill (+ x 2) (list-ref y yCursor) (- 130 x) 11 white)
	       (if (eq? (- yCursor 1) -1)
		(set! yCursor (- sizeListY 1))
		(set! yCursor (- yCursor 1)))
	       (drawCursorR xCursor (list-ref y yCursor) 10 color)
	       (wait 4000)
	       (action))
	      ((set? button3) 
	       (fill (+ x 2) (list-ref y yCursor) (- 130 x) 11 white)
	       (set! yCursor (modulo (+ yCursor 1) sizeListY))
	       (drawCursorR xCursor (list-ref y yCursor) 10 color)
	       (wait 4000)
	       (action))
	      ((set? button2)
	       (cond 
		((eq? yCursor 0) (playGame guessing-game))
		((eq? yCursor 1) (playGame rock-paper-scissor))
		;;((eq? yCursor 2) 'tic-tac-toe)
		((eq? yCursor 2) 'exit)))
	        (else (action))))
	     (action)))
   ) port)
(close-output-port port))

;; driverLoop
(let ((port (open-output-file "driverLoop")))
 (write '(begin
	  ;; load necessary libraries
	  (load "monster")
	  (load "menu")
	  (load "games")
	  ;; driverLoop
	  (define (driverLoop)
	   (if (eq? (startingMenu) 'play)
	    (begin
	     (define action 'null)
	     (define m (monster))
	     (m 'born)
	     (waitSkip 10000)
	     (m 'draw)
	     ((m 'presentYourself) 10000)
	     ;; action in the menu
	     (define (actionInTheMenu)
	      (set! action (menu))
	      (cond 
	       ((eq? action 'about) (aboutMenu m) (actionInTheMenu))
	       ((eq? action 'play) (gameMenu 0 m) (actionInTheMenu))
	       (else
		(m 'draw)
		(cond 
		 ((eq? action 'feed) (feedMenu m))
		 ((eq? action 'sleep) (m 'sleep))
		 ((eq? action 'clean) (m 'clean))
		 ((eq? action 'drug) (drugMenu m)))
		(wait 4000))))
	     ;; Main Loop
	     (define (mainLoop)
	      (if (eq? (m 'checkState) 'dead)
	       (driverLoop)
	       (begin
		(if (and (not (m 'isSleeping?)) (> (pulse_in x-pin) 21000)) (m 'sleep))
		(if (and (m 'isSleeping?) (< (pulse_in x-pin) 15200)) (m 'sleep))
	        (if (set-button?)
		 (if (m 'isSleeping?)
		  (m 'sleep)
		  (actionInTheMenu)))
		 (m 'update)
		 (mainLoop))))
	      (mainLoop))
	   (clear-screen)))
   ) port)
(close-output-port port))

;; Monster
(let ((port (open-output-file "monster")))
 (write '(begin
	  ;; load necessary library
	  (load "char")
	  ;; Definition of the monster
	  (define (monster)
	   (let* ((x 65)
		  (y 65)
		  (radius 35)
		  (radius/2 (round (/ radius 2)))
		  (life 1000)
		  (health 100) (prevHealth 100)
		  (happiness 100) (prevHappiness 100)
		  (hunger 60) (prevHunger 60)
		  (awakeness 100) (prevAwakeness 100)
		  (submissiveness 100) (prevSubmissiveness 100)
		  (cleanliness 100) (prevCleanliness 100)
		  (sentence "") (prevSentence "")
		  (isSleeping #f)
		  (time 0)
		  (probToilet 0))
	    ;; Draw the monster is born
	    (define (born)
	     (let* ((x0 (+ x radius))
		    (y0 y)
		    (x1 (+ x radius/2))
		    (y1 (+ y 10))
		    (x2 x)
		    (y2 (- y 10))
		    (x3 (- x radius/2))
		    (y3 y1)
		    (x4 (- x radius))
		    (y4 y))
	      (clear-screen)
	      ;; Body
	      (drawCurve x y radius radius 1 pi pi2 black 240)
	      (drawCurve x y radius (+ 15 radius) 1 0 pi black 240)
	      ;; mark/spot
	      (fillCircle (- x (round (/ radius 5))) (+ y radius) 4 red)
	      (fillCircle x1 y2 4 green)
	      (fillCircle x3 (- y radius/2) 4 blue)
	      ;; Trying to hatch
	      (drawCurve x y (+ radius 5) (+ radius 20) 1 (+ 0 pi/8 pi/16) (- pi/2 pi/8 pi/16) black)
	      (drawCurve x y (+ radius 5) (+ radius 20) 1 (+ pi/2 pi/8 pi/16) (- pi pi/8 pi/16) black)
	      (drawCurve x y (+ radius 5) (+ radius 5) 1 (+ pi pi/8 pi/16) (- pi3/2 pi/8 pi/16) black)
	      (drawCurve x y (+ radius 5) (+ radius 5) 1 (+ pi3/2 pi/8 pi/16) (- pi2 pi/8 pi/16) black)
	      (drawCurve x y (+ radius 10) (+ radius 25) 1 (+ 0 pi/8) (- pi/2 pi/8) black)
	      (drawCurve x y (+ radius 10) (+ radius 25) 1 (+ pi/2 pi/8) (- pi pi/8) black)
	      (drawCurve x y (+ radius 10) (+ radius 10) 1 (+ pi pi/8) (- pi3/2 pi/8) black)
	      (drawCurve x y (+ radius 10) (+ radius 10) 1 (+ pi3/2 pi/8) (- pi2 pi/8) black)
	      (wait 20000)
	      ;; hatch
	      (drawLine x0 y0 x1 y1 1 black)
	      (drawLine x1 y1 x2 y2 1 black)
	      (drawLine x2 y2 x3 y3 1 black)
	      (drawLine x3 y3 x4 y4 1 black)))
	  ;; Draw mouth
	  (define (drawMouth)
	   (define (clearMouth)
	    (fill (- x 17) (+ y 6) 36 15 white))
	   (clearMouth)
	   (cond 
	    ((> happiness 66) (drawCurve x (+ y 20) (- radius 20) (- radius 25) 1 pi pi2 black 240) )
	    ((< happiness 33) (drawCurve x (+ y 10) (- radius 20) (- radius 25) 1 0 pi black 240) )
	    (else (drawLine (+ x 10) (+ y 15) (- x 10) (+ y 15) 2 black) )))
	  ;; Draw eyes
	  (define (drawEyes)
	   (define (clearEyes)
	    (fill (- x 17) (+ y 23) 36 10 white))
	   (define (drawOpenedEyes)
	    (drawCurve (+ x 10) (+ y 25) 5 5 1 0 pi black 240)
	    (fill (+ x 9) (+ y 26) 3 3 black)
      	    (drawLine (+ x 5) (+ y 25) (+ x 15) (+ y 25) 1 black)
	    (drawCurve (- x 10) (+ y 25) 5 5 1 0 pi black 240)
	    (fill (- x 11) (+ y 26) 3 3 black)
	    (drawLine (- x 15) (+ y 25) (- x 5) (+ y 25) 1 black))
	   (define (drawClosedEyes)
	    (drawLine (- x 15) (+ y 26) (- x 3) (+ y 26) 2 black)
	    (drawLine (+ x 5) (+ y 26) (+ x 17) (+ y 26) 2 black))
	   (define (clearDarkRings)
	    (fill (- x 17) (+ y 23) 36 2 white))
	   (cond
	    (isSleeping 
	     (clearEyes) 
	     (drawClosedEyes))
	    ((> awakeness 66) 
	     (clearEyes) 
	     (drawOpenedEyes))
	    ((< awakeness 33) 
	     (clearEyes)
	     (drawOpenedEyes)
	     (drawLine (- x 15) (+ y 24) (- x 3) (+ y 24) 1 black)
	     (drawLine (+ x 5) (+ y 24) (+ x 17) (+ y 24) 1 black)
	     (drawLine (- x 15) (+ y 23) (- x 3) (+ y 23) 1 black)
	     (drawLine (+ x 5) (+ y 23) (+ x 17) (+ y 23) 1 black))
	    (else
	     (clearEyes)
	     (drawOpenedEyes)
	     (drawLine (- x 15) (+ y 24) (- x 3) (+ y 24) 1 black)
	     (drawLine (+ x 5) (+ y 24) (+ x 17) (+ y 24) 1 black))))
	  ;; Draw stomach level
	  (define (drawStomachLevel)
	   (let ((level (round (* hunger (/ 18 100)))))
	    (cond 
	     ((eq? level 0) (fill 56 41 18 18 blue))
	     ((eq? level 18) (fill 56 41 18 18 white))
	     (else (fill 56 41 18 (- 18 level) blue) (fill 56 (+ 41 (- 18 level)) 18 level white)))))
	  ;; Draw eyebrows
	  (define (drawEyebrows)
	   (define (clearEyebrows)
	    (fill (- x 15) (+ y 32) 31 5 white))
	   (clearEyebrows)
	   (cond
	    ((> submissiveness 66)
	     (drawLine (+ x 15) (+ y 32) (+ x 10) (+ y 35) 1 black)
	     (drawLine (- x 15) (+ y 32) (- x 10) (+ y 35) 1 black))
	    ((< submissiveness 33)
	     (drawLine (+ x 10) (+ y 36) (+ x 5) (+ y 32) 1 black)
	     (drawLine (- x 10) (+ y 36) (- x 5) (+ y 32) 1 black))
	    (else
	     (drawLine (+ x 13) (+ y 34) (+ x 6) (+ y 34) 1 black)
	     (drawLine (- x 13) (+ y 34) (- x 6) (+ y 34) 1 black))))
	  ;; Draw sickness mark
	  (define (drawSicknessMark n color)
	   (cond 
	    ((eq? n 1) (fillCircle 45 45 4 color))
	    ((eq? n 2) (fillCircle 88 60 4 color))
	    ((eq? n 3) (fillCircle 56 66 4 color))
	    ((eq? n 4) (fillCircle 40 81 4 color))
	    ((eq? n 5) (fillCircle 75 106 4 color))))
	  ;; Draw Sickness
	  (define (drawSickness)
	   (if (< health 83)
	    (begin (drawSicknessMark 1 red)
	     (if (< health 67)
	      (begin (drawSicknessMark 2 red)
	       (if (< health 50)
		(begin (drawSicknessMark 3 red)
		 (if (< health 33)
		  (begin (drawSicknessMark 4 red)
		   (if (< health 17)
		    (drawSicknessMark 5 red)))))))))))
	  ;; Draw add sickness
	  (define (drawAddSickness)
	   (cond
	    ((< health 17) (drawSicknessMark 5 red))
	    ((< health 33) (drawSicknessMark 4 red))
	    ((< health 50) (drawSicknessMark 3 red))
	    ((< health 67) (drawSicknessMark 2 red))
	    ((< health 83) (drawSicknessMark 1 red))))
	  ;; Draw remove sickness
	  (define (drawRemoveSickness)
	   (cond 
	    ((>= health 83) (drawSicknessMark 1 white))
	    ((>= health 67) (drawSicknessMark 2 white))
	    ((>= health 50) (drawSicknessMark 3 white))
	    ((>= health 33) (drawSicknessMark 4 white))
	    ((>= health 17) (drawSicknessMark 5 white))))
	  ;; Draw droppings
	  (define (drawDroppings n)
	   (cond 
	    ((eq? n 1) (fill (+ x 35) (+ y 40) 3 3 black))
	    ((eq? n 2) (fill (+ x 45) (+ y 45) 3 3 black))
	    ((eq? n 3) (fill (+ x 40) (+ y 50) 3 3 black))
	    ((eq? n 4) (fill (+ x 50) (+ y 35) 3 3 black))
	    ((eq? n 5) (fill (+ x 52) (+ y 47) 3 3 black))))
   	  ;; Draw the monster
	  (define (draw)
	   (clear-screen)
	   ;; Body
	   (drawCurve x y radius radius 1 pi pi2 black 240)
	   (drawCurve x y radius (+ 15 radius) 1 0 pi black 240)
	   (drawEyebrows)
	   (drawEyes)
	   (drawMouth)
      	   ;; Hands
	   (drawTriangle 98 68 110 81 94 76 1 black)
	   (drawTriangle 32 68 20 81 36 76 1 black)
	   ;; Stomach
	   (drawRectangle 55 40 20 20 1 black)
	   (drawStomachLevel)
	   ;; Sickness
	   (drawSickness))

	  ;; clear text
	  (define (clear-text)
	   (fill 0 0 130 30 white))
	  ;; say
	  (define (say str)
	   (clear-text)
	   (print str 120 10 12 black))
	  ;; present yourself
	  (define (presentYourself time)
	   (if (and (integer? time) (>= time 0))
	    (begin
	     (say "Hi master!")
	     (waitSkip time)
	     (say "My name is")
	     (waitSkip time)
	     (say "boxy.")
	     (waitSkip time)
	     (say ""))))
	  ;; sleep
	  (define (sleep)
	   (if (not isSleeping)
	    (begin
	     (set! isSleeping #t)
	     (say " ")
	     (drawEyes)
	     (print "z" 30 90 10 black)
	     (print "z" 20 100 12 black)
	     (print "z" 10 110 16 black))
	    (begin
	     (set! isSleeping #f)
	     (print "z" 30 90 10 white)
	     (print "z" 20 100 12 white)
	     (print "z" 10 110 16 white)
	     (drawEyes)
	     (say "I'm awake!"))))
	  ;; die
	  (define (die)
	   (drawEllipse 65 118 20 8 2 yellow 240)
	   (print "your pet died" 120 10 10 black))
	  ;; isAlive?
	  (define (isAlive?)
	   (if (> life 0) #t #f))
	  ;; checkState
	  (define (checkState)
	   (if (or (<= health 0) (>= hunger 100) (<= awakeness 0)) 
	    (set! life 0))
	   (if (not (isAlive?))
	    (begin (die) (waitSkip 20000) 'dead)
	    (if (not isSleeping)
	     (begin
	      (set! prevSentence sentence)
	      (cond
	       ((and (< health 50) (< health (- 100 hunger)) (< health awakeness)) (set! sentence "I'm sick"))
	       ((and (> hunger 50) (> hunger (- 100 awakeness))) (set! sentence "I'm hungry"))
	       ((and (< awakeness 50) ) (set! sentence "I'm tired"))
	       ((or (< happiness 60) (< submissiveness 60)) (set! sentence "wanna play?"))
	       ((< cleanliness 88) (set! sentence "toilet"))
	       ((< cleanliness 60) (set! sentence "clean me"))))))
	       ;;(else prob (set! sentence "wanna play?"))))))
	   (if (not (eq? sentence prevSentence)) (say sentence)))
	  ;; feed
	  (define (feed food)
	   (cond 
	    ((eq? food 'snack)
	     (display "snack")
	     (set! hunger (max (- hunger 5) 0))
	     (set! happiness (min (+ happiness 1) 100))
	     (set! health (max (- health 2) 9))
	     (drawStomachLevel))
	    ((eq? food 'meal)
	     (display "meal")
	     (set! hunger (max (- hunger 10) 0))
	     (drawStomachLevel))))
	  ;; play
	  (define (play)
	   (set! happiness (min (+ happiness  3) 100))
	   (set! submissiveness (min (+ submissiveness 2) 100)))
	  ;; update
	  (define (update)
	   (set! time (modulo (+ time 1) 100))
	   (if (eq? time 0)
	    (if isSleeping 
	     (set! awakeness (min (+ awakeness 1) 100))
	     (begin
	      (set! life (max (- life 1) 0))
	      ;; health
	      (set! prevHealth health)
	      (set! health (max (- health 1) 0))
	      (if (<= cleanliness 25) 
	       (set! health (max (- health 3) 0))
	       (if (<= cleanliness 50) 
		(set! health (max (- health 2) 0))
		(if (<= cleanliness 75)
		 (set! health (max (- health 1) 0)))))
	      (if (or (and (< health 17) (>= prevHealth 17)) (and (< health 33) (>= prevHealth 33)) (and (< health 50) (>= prevHealth 50))
		   (and (< health 67) (>= prevHealth 67)) (and (< health 83) (>= prevHealth 83)))
	       (drawAddSickness))
	      ;; happiness
	      (set! prevHappiness happiness)
	      (set! happiness (max (- happiness 2) 0))
	      (if (or (and (<= happiness 66) (> prevHappiness 66)) (and (< happiness 33) (>= prevHappiness 33)))
	       (drawMouth))
	      ;; hunger
	      (set! prevHunger hunger)
	      (set! hunger (min (+ hunger 3) 100))
	      (drawStomachLevel)
	      ;; awakeness
	      (set! prevAwakeness awakeness)
	      (set! awakeness (max (- awakeness 3) 0))
	      (if (or (and (<= awakeness 66) (> prevAwakeness 66)) (and (< awakeness 33) (>= prevAwakeness 33)))
	       (drawEyes))
	      ;; submissiveness
	      (set! prevSubmissiveness submissiveness)
	      (set! submissiveness (max (- submissiveness 1) 0))
	      (if (or (and (<= submissiveness 66) (> prevSubmissiveness 66)) (and (< submissiveness 33) (>= prevSubmissiveness 33)))
	       (drawEyebrows))
	      ;; cleanliness
	      (set! prevCleanliness cleanliness)
	      (if (> (random 1 10) probToilet) (set! cleanliness (max (- cleanliness 3) 0)))
	      (if (< cleanliness 80)
	       (begin (drawDroppings 1) 
		(if (< cleanliness 60)
		 (begin (drawDroppings 2)
		  (if (< cleanliness 40)
		   (begin (drawDroppings 3)
		    (if (< cleanliness 20)
		     (begin (drawDroppings 4)
		      (if (< cleanliness 10) (drawDroppings 5))))))))))
	     ))))
	  ;; clean
	  (define (clean)
	   (display "cleaning")
	   (if (< cleanliness 80)
	    (fill (+ x 31) (+ y 30) 30 30 white)
	    (set! probToilet (min (+ probToilet 1) 10)))
	   (set! cleanliness 100))
	  ;; give drugs
	  (define (giveDrugs)
	   (display "giving drugs")
	   (set! health (min (+ health 10) 100))
	   (drawRemoveSickness))
   	  ;; dispatch
	  (define (dispatch m)
	   (cond 
	    ((eq? m 'born) (born))
	    ((eq? m 'draw) (draw))
	    ((eq? m 'isAMonster?) #t)
	    ((eq? m 'say) say)
	    ((eq? m 'presentYourself) presentYourself)
      	    ((eq? m 'sleep) (sleep))
	    ((eq? m 'die) (die))
	    ((eq? m 'isAlive?) (isAlive?))
	    ((eq? m 'checkState) (checkState))
	    ((eq? m 'feed) feed)
	    ((eq? m 'play) (play))
	    ((eq? m 'update) (update))
	    ((eq? m 'clean) (clean))
	    ((eq? m 'giveDrugs) (giveDrugs))
	    ((eq? m 'isSleeping?) isSleeping)
	    ((eq? m 'getLife) life)
	    ((eq? m 'getHealth) health)
	    ((eq? m 'getHappiness) happiness)
	    ((eq? m 'getHunger) hunger)
	    ((eq? m 'getAwakeness) awakeness)
	    ((eq? m 'getSubmissiveness) submissiveness)
	    ((eq? m 'getCleanliness) cleanliness)
	    ))
	  dispatch))
   ) port)
(close-output-port port))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

;; FSM
(let ((port (open-output-file "fsm")))
 (write '(begin
	  (define (get-input context input-name)
	   (assoc input-name context))
	  (define input-value cdr)
	  
	  (define (make-finite-state-machine start-state)
	   (let ((current-state start-state)
		 (current-transitions (start-state 'transitions)))
	    
	    (define (get-transition-inputs)
	     (map transition-input-name current-transitions))
	    
	    (define (feed-context context)
	     (for-each (lambda (transition)
		  (let ((input (get-input context (transition-input-name transition))))
		    (if (and input
			     ((transition-predicate transition) (input-value input)))
			(change-state (transition-state transition)))))
		current-transitions))
	    
	    (define (change-state new-state)
	     (if (not (equal? new-state current-state))
	      (begin 
	       (current-state 'exit-action)
	       (new-state 'entry-action)
	       (set! current-transitions (new-state 'transitions))
	       (set! current-state new-state))))

	    (lambda (msg . args)
	     (case msg
	      ('feed-context (apply feed-context args))
	      ('get-inputs (get-transition-inputs))
	      (else (error "Msg not understood: " msg))))))

	    (define (make-transition input-name predicate new-state) 
	     (list input-name predicate new-state))
	    
	    (define transition-input-name car)
	    (define transition-predicate cadr)
	    (define transition-state caddr)
	    (define (do-nothing) '())
	    
	    (define (make-state entry-action exit-action . transitions)
	     (define (add-transition transition)
	      (set! transitions (cons transition transitions)))
	     (lambda (msg . args)
	      (case msg
	       ('entry-action (entry-action))
	       ('exit-action (exit-action))
	       ('transitions transitions)
	       ('add-transition (apply add-transition args))
	       (else (error "Msg not understood: " msg)))))
   ) port)
(close-output-port port))

(let ((port (open-output-file "monsterFSM")))
 (write '(begin
	  ;; load libraries
	  (load "char")
	  (load "fsm")
	  ;; Monster
	  (define (monsterFSM)
	   (let* ((x 65)
		  (y 65)
		  (radius 35)
		  (radius/2 (round (/ radius 2)))
		  (life 1000)
		  (health 100) (prevHealth 100)
		  (happiness 100) (prevHappiness 100)
		  (hunger 60) (prevHunger 60)
		  (awakeness 100) (prevAwakeness 100)
		  (submissiveness 100) (prevSubmissiveness 100)
		  (cleanliness 100) (prevCleanliness 100)
		  (isSleeping #f)
		  (time 0)
		  (probToilet 0))

	    ;; Draw the monster is born
	    (define (born)
	     (let* ((x0 (+ x radius))
		    (y0 y)
		    (x1 (+ x radius/2))
		    (y1 (+ y 10))
		    (x2 x)
		    (y2 (- y 10))
		    (x3 (- x radius/2))
		    (y3 y1)
		    (x4 (- x radius))
		    (y4 y))
	      (clear-screen)
	      ;; Body
	      (drawCurve x y radius radius 1 pi pi2 black 240)
	      (drawCurve x y radius (+ 15 radius) 1 0 pi black 240)
	      ;; mark/spot
	      (fillCircle (- x (round (/ radius 5))) (+ y radius) 4 red)
	      (fillCircle x1 y2 4 green)
	      (fillCircle x3 (- y radius/2) 4 blue)
	      ;; Trying to hatch
	      (drawCurve x y (+ radius 5) (+ radius 20) 1 (+ 0 pi/8 pi/16) (- pi/2 pi/8 pi/16) black)
	      (drawCurve x y (+ radius 5) (+ radius 20) 1 (+ pi/2 pi/8 pi/16) (- pi pi/8 pi/16) black)
	      (drawCurve x y (+ radius 5) (+ radius 5) 1 (+ pi pi/8 pi/16) (- pi3/2 pi/8 pi/16) black)
	      (drawCurve x y (+ radius 5) (+ radius 5) 1 (+ pi3/2 pi/8 pi/16) (- pi2 pi/8 pi/16) black)
	      (drawCurve x y (+ radius 10) (+ radius 25) 1 (+ 0 pi/8) (- pi/2 pi/8) black)
	      (drawCurve x y (+ radius 10) (+ radius 25) 1 (+ pi/2 pi/8) (- pi pi/8) black)
	      (drawCurve x y (+ radius 10) (+ radius 10) 1 (+ pi pi/8) (- pi3/2 pi/8) black)
	      (drawCurve x y (+ radius 10) (+ radius 10) 1 (+ pi3/2 pi/8) (- pi2 pi/8) black)
	      (wait 20000)
	      ;; hatch
	      (drawLine x0 y0 x1 y1 1 black)
	      (drawLine x1 y1 x2 y2 1 black)
	      (drawLine x2 y2 x3 y3 1 black)
	      (drawLine x3 y3 x4 y4 1 black)))

	    ;; Draw mouth
	  (define (drawMouth)
	   (define (clearMouth)
	    (fill (- x 17) (+ y 6) 36 15 white))
	   (clearMouth)
	   (cond 
	    ((> happiness 66) (drawCurve x (+ y 20) (- radius 20) (- radius 25) 1 pi pi2 black 240) )
	    ((< happiness 33) (drawCurve x (+ y 10) (- radius 20) (- radius 25) 1 0 pi black 240) )
	    (else (drawLine (+ x 10) (+ y 15) (- x 10) (+ y 15) 2 black) )))
	  ;; Draw eyes
	  (define (drawEyes)
	   (define (clearEyes)
	    (fill (- x 17) (+ y 23) 36 10 white))
	   (define (drawOpenedEyes)
	    (drawCurve (+ x 10) (+ y 25) 5 5 1 0 pi black 240)
	    (fill (+ x 9) (+ y 26) 3 3 black)
      	    (drawLine (+ x 5) (+ y 25) (+ x 15) (+ y 25) 1 black)
	    (drawCurve (- x 10) (+ y 25) 5 5 1 0 pi black 240)
	    (fill (- x 11) (+ y 26) 3 3 black)
	    (drawLine (- x 15) (+ y 25) (- x 5) (+ y 25) 1 black))
	   (define (drawClosedEyes)
	    (drawLine (- x 15) (+ y 26) (- x 3) (+ y 26) 2 black)
	    (drawLine (+ x 5) (+ y 26) (+ x 17) (+ y 26) 2 black))
	   (define (clearDarkRings)
	    (fill (- x 17) (+ y 23) 36 2 white))
	   (cond
	    (isSleeping 
	     (clearEyes) 
	     (drawClosedEyes))
	    ((> awakeness 66) 
	     (clearEyes) 
	     (drawOpenedEyes))
	    ((< awakeness 33) 
	     (clearEyes)
	     (drawOpenedEyes)
	     (drawLine (- x 15) (+ y 24) (- x 3) (+ y 24) 1 black)
	     (drawLine (+ x 5) (+ y 24) (+ x 17) (+ y 24) 1 black)
	     (drawLine (- x 15) (+ y 23) (- x 3) (+ y 23) 1 black)
	     (drawLine (+ x 5) (+ y 23) (+ x 17) (+ y 23) 1 black))
	    (else
	     (clearEyes)
	     (drawOpenedEyes)
	     (drawLine (- x 15) (+ y 24) (- x 3) (+ y 24) 1 black)
	     (drawLine (+ x 5) (+ y 24) (+ x 17) (+ y 24) 1 black))))
	  ;; Draw stomach level
	  (define (drawStomachLevel)
	   (let ((level (round (* hunger (/ 18 100)))))
	    (cond 
	     ((eq? level 0) (fill 56 41 18 18 blue))
	     ((eq? level 18) (fill 56 41 18 18 white))
	     (else (fill 56 41 18 (- 18 level) blue) (fill 56 (+ 41 (- 18 level)) 18 level white)))))
	  ;; Draw eyebrows
	  (define (drawEyebrows)
	   (define (clearEyebrows)
	    (fill (- x 15) (+ y 32) 31 5 white))
	   (clearEyebrows)
	   (cond
	    ((> submissiveness 66)
	     (drawLine (+ x 15) (+ y 32) (+ x 10) (+ y 35) 1 black)
	     (drawLine (- x 15) (+ y 32) (- x 10) (+ y 35) 1 black))
	    ((< submissiveness 33)
	     (drawLine (+ x 10) (+ y 36) (+ x 5) (+ y 32) 1 black)
	     (drawLine (- x 10) (+ y 36) (- x 5) (+ y 32) 1 black))
	    (else
	     (drawLine (+ x 13) (+ y 34) (+ x 6) (+ y 34) 1 black)
	     (drawLine (- x 13) (+ y 34) (- x 6) (+ y 34) 1 black))))
	    ;; Draw sickness mark
	  (define (drawSicknessMark n color)
	   (cond 
	    ((eq? n 1) (fillCircle 45 45 4 color))
	    ((eq? n 2) (fillCircle 88 60 4 color))
	    ((eq? n 3) (fillCircle 56 66 4 color))
	    ((eq? n 4) (fillCircle 40 81 4 color))
	    ((eq? n 5) (fillCircle 75 106 4 color))))
	  ;; Draw Sickness
	  (define (drawSickness)
	   (if (< health 83)
	    (begin (drawSicknessMark 1 red)
	     (if (< health 67)
	      (begin (drawSicknessMark 2 red)
	       (if (< health 50)
		(begin (drawSicknessMark 3 red)
		 (if (< health 33)
		  (begin (drawSicknessMark 4 red)
		   (if (< health 17)
		    (drawSicknessMark 5 red)))))))))))
	    ;; Draw add sickness
	  (define (drawAddSickness)
	   (cond
	    ((< health 17) (drawSicknessMark 5 red))
	    ((< health 33) (drawSicknessMark 4 red))
	    ((< health 50) (drawSicknessMark 3 red))
	    ((< health 67) (drawSicknessMark 2 red))
	    ((< health 83) (drawSicknessMark 1 red))))
	  ;; Draw remove sickness
	  (define (drawRemoveSickness)
	   (cond 
	    ((>= health 83) (drawSicknessMark 1 white))
	    ((>= health 67) (drawSicknessMark 2 white))
	    ((>= health 50) (drawSicknessMark 3 white))
	    ((>= health 33) (drawSicknessMark 4 white))
	    ((>= health 17) (drawSicknessMark 5 white))))
	  ;; Draw droppings
	  (define (drawDroppings n)
	   (cond 
	    ((eq? n 1) (fill (+ x 35) (+ y 40) 3 3 black))
	    ((eq? n 2) (fill (+ x 45) (+ y 45) 3 3 black))
	    ((eq? n 3) (fill (+ x 40) (+ y 50) 3 3 black))
	    ((eq? n 4) (fill (+ x 50) (+ y 35) 3 3 black))
	    ((eq? n 5) (fill (+ x 52) (+ y 47) 3 3 black))))

	    ;; Draw the monster
	  (define (draw)
	   (clear-screen)
	   ;; Body
	   (drawCurve x y radius radius 1 pi pi2 black 240)
	   (drawCurve x y radius (+ 15 radius) 1 0 pi black 240)
	   (drawEyebrows)
	   (drawEyes)
	   (drawMouth)
      	   ;; Hands
	   (drawTriangle 98 68 110 81 94 76 1 black)
	   (drawTriangle 32 68 20 81 36 76 1 black)
	   ;; Stomach
	   (drawRectangle 55 40 20 20 1 black)
	   (drawStomachLevel)
	   ;; Sickness
	   (drawSickness))

	    ;; clear text
	    (define (clear-text)
	     (fill 0 0 130 30 white))
	    ;; say
	    (define (say str)
	     (clear-text)
	     (print str 120 10 12 black))
	    ;; present yourself
	  (define (presentYourself time)
	   (if (and (integer? time) (>= time 0))
	    (begin
	     (say "Hi master!")
	     (waitSkip time)
	     (say "My name is")
	     (waitSkip time)
	     (say "boxy.")
	     (waitSkip time)
	     (say ""))))
	  ;; sleep
	  (define (sleep)
	   (if (not isSleeping)
	    (begin
	     (set! isSleeping #t)
	     (say " ")
	     (drawEyes)
	     (print "z" 30 90 10 black)
	     (print "z" 20 100 12 black)
	     (print "z" 10 110 16 black))
	    (begin
	     (set! isSleeping #f)
	     (print "z" 30 90 10 white)
	     (print "z" 20 100 12 white)
	     (print "z" 10 110 16 white)
	     (drawEyes)
	     (say "I'm awake!"))))
	  ;; die
	  (define (die)
	   (drawEllipse 65 118 20 8 2 yellow 240)
	   (print "your pet died" 120 10 10 black)
	   (waitSkip 40000))
	  ;; isAlive?
	  (define (isAlive?)
	   (if (> life 0) #t #f))
	 ;; checkState
	  (define (checkState)
	   (if (or (<= health 0) (>= hunger 100) (<= awakeness 0)) 
	    (set! life 0))
	   (if (not (isAlive?))
	    (begin (die) (waitSkip 20000) 'dead)))

	    
	    ;;;;;;;;;;;;;; STATES ;;;;;;;;;;;;;; 

	    ;; Sad State
	    (define sad-state (make-state (lambda () (drawMouth)) 
					  do-nothing))
	    ;; Happy State
	    (define happy-state (make-state (lambda () (drawMouth))
					    (lambda () (say "wanna play?"))))
      	    ;; timer transition (n=2)
	    (define time-happiness-transition
	     (make-transition
	      'timer
	      (lambda (n)
	       (set! happiness (max (- happiness n) 0))
	       (if (< happiness 50) #t #f))
	      sad-state))
	    ;; play transition (n=3)
	    (define play-transition
	     (make-transition
	      'play
	      (lambda (n) 
	       (set! happiness (min (+ happiness n) 100))
	       (if (>= happiness 50) #t #f))
	      happy-state))
	    ;; add the transitions
	    (happy-state 'add-transition time-happiness-transition)
	    (sad-state 'add-transition time-happiness-transition)
	    (happy-state 'add-transition play-transition)
	    (sad-state 'add-transition play-transition)

      	    ;; Ill State
	    (define ill-state (make-state (lambda () (drawSickness))
					  do-nothing))
	    ;; Healthy State
	    (define healthy-state (make-state (lambda () (drawHealth))
					  (lambda () (say "I'm sick"))))
	    ;; timer transition (n=1)
	    (define time-health-transition
	     (make-transition
	      'timer
	      (lambda (n)
	       (set! health (max (- health n) 0))
	       (if (< health 50) #t #f))
	      ill-state))
	    ;; drug-transition (n=10)
	    (define drug-transition
	     (make-transition
	      'giveDrugs
	      (lambda (n)
	       (set! health (min (+ health n) 100))
	       (if (>= health 50) #t #f))
	      healthy-state))
	    ;; add the transitions
	    (healthy-state 'add-transition time-health-transition)
	    (ill-state 'add-transition time-health-transition)
	    (healthy-state 'add-transition drug-transition)
	    (ill-state 'add-transition drug-transition)

	    ;; Hungry State
	    (define hungry-state (make-state (lambda () (drawStomach))
					  do-nothing))
	    ;; Satisfied State
	    (define satisfied-state (make-state (lambda () (drawStomach))
					  (lambda () (say "I'm hungry"))))
	    ;; timer transition (n=3)
	    (define time-hunger-transition
	     (make-transition
	      'timer
	      (lambda (n)
	       (set! hunger (min (+ hunger n) 100))
      	       (drawStomach)
	       (if (> hunger 50) #t #f))
	      hungry-state))
	    ;; feed-transition (n=10 if meal, n=5 snack)
	    (define feed-transition
	     (make-transition
	      'feed
	      (lambda (n)
	       (set! hunger (max (- hunger n) 0))
      	       (drawStomach)
	       (if (<= hunger 50) #t #f))
	      satisfied-state))
	    ;; add the transitions
	    (satisfied-state 'add-transition time-hunger-transition)
	    (hungry-state 'add-transition time-hunger-transition)
	    (satisfied-state 'add-transition feed-transition)
	    (hungry-state 'add-transition feed-transition)

	    ;; Exhausted State
	    (define exhausted-state (make-state (lambda () (drawEyes))
					  do-nothing))
	    ;; Awake State
	    (define awake-state (make-state (lambda () (drawEyes))
					  (lambda () (say "I'm tired"))))
	    ;; Sleep State
	    (define sleep-state
	     (let ((sleep-state (make-state (lambda () '())
					    (lambda () '()))))
	      (sleep-state 'add-transition (make-transition 
					    'wakeup1
					    (lambda (n) (if (< awakeness 50) #t #f))
					    exhausted-state))
	      (sleep-state 'add-transition (make-transition 
					    'wakeup2
					    (lambda (n) (if (>= awakeness 50) #t #f))
					    awake-state))
	      sleep-state))
	    ;; timer transition (n=3)
	    (define time-awakeness-transition
	     (make-transition
	      'timer
	      (lambda (n)
	       (set! awakeness (max (- awakeness n) 0))
      	       (if (< awakeness 50) #t #f))
	      exhausted-state))
	    ;; sleep-transition (n=1)
	    (define sleep-transition
	     (make-transition
	      'sleep
	      (lambda (n) (set! awakeness (min (+ awakeness n) 100)) #t)
   	      sleep-state))
	    ;; add the transitions
	    (awake-state 'add-transition time-awakeness-transition)
	    (exhausted-state 'add-transition time-awakeness-transition)
	    (awake-state 'add-transition sleep-transition)
	    (exhausted-state 'add-transition sleep-transition)
	    (sleep-state 'add-transition sleep-transition)
	    
	    
	    ;; Rebellious State
	    (define rebellious-state (make-state (lambda () (drawEyebrows))
					  do-nothing))
	    ;; Submissive State
	    (define submissive-state (make-state (lambda () (drawEyebrows))
					  (lambda () (say "rebellion"))))
	    ;; timer transition (n=1)
	    (define time-submissiveness-transition
	     (make-transition
	      'timer
	      (lambda (n)
	       (set! submissiveness (max (- submissiveness n) 0))
      	       (if (< submissiveness 50) #t #f))
	      rebellious-state))
	    ;; submission-transition (n=2)
	    (define submission-transition
	     (make-transition
	      'submission
	      (lambda (n)
	       (set! submissiveness (min (+ submissiveness n) 100))
      	       (if (>= submissiveness 50) #t #f))
	      submissive-state))
	    ;; add the transitions
	    (submissive-state 'add-transition time-submissiveness-transition)
	    (rebellious-state 'add-transition time-submissiveness-transition)
	    (submissive-state 'add-transition submission-transition)
	    (rebellious-state 'add-transition submission-transition)

	    ;; FSM
	    (define fsmHappiness (make-finite-state-machine happy-state))
	    (define fsmHealth (make-finite-state-machine healthy-state))
	    (define fsmHunger (make-finite-state-machine hungry-state))
	    (define fsmAwakeness (make-finite-state-machine awake-state))
	    (define fsmSubmissiveness (make-finite-state-machine submissiveness-state))

	    ;; update
	    (define (update)
	     (set! time (modulo (+ time 1) 100))
	     (if (eq? time 0)
	      (if isSleeping
	       (fsmAwakeness 'feed-context (list (cons 'sleep 1)))
	       (begin
		(set! life (max (- life 1) 0))
		(set! prevSubmissiveness submissiveness)
		(set! prevHunger hunger)
		(set! prevAwakeness awakeness)
		(set! prevHealth health)
		(set! prevHappiness happiness)
	        ;; FSM
	        (fsmHappiness 'feed-context (list (cons 'timer 1)))
	        (fsmHealth 'feed-context (list (cons 'timer 1)))
	        (fsmAwakeness 'feed-context (list (cons 'timer 1)))
	        (fsmHunger 'feed-context (list (cons 'timer 1)))
	        (fsmSubmissiveness 'feed-context (list (cons 'timer 1)))
		;; drawings
		(if (or (and (< health 17) (>= prevHealth 17)) (and (< health 33) (>= prevHealth 33)) (and (< health 50) (>= prevHealth 50))
		   (and (< health 67) (>= prevHealth 67)) (and (< health 83) (>= prevHealth 83)))
	       (drawAddSickness))
		(if (or (and (<= happiness 66) (> prevHappiness 66)) (and (< happiness 33) (>= prevHappiness 33)))
	       (drawMouth))
		(if (or (and (<= awakeness 66) (> prevAwakeness 66)) (and (< awakeness 33) (>= prevAwakeness 33)))
	       (drawEyes))
	       (if (or (and (<= submissiveness 66) (> prevSubmissiveness 66)) (and (< submissiveness 33) (>= prevSubmissiveness 33)))
	        (drawEyebrows))
		;; cleanliness
	      (set! prevCleanliness cleanliness)
	      (if (> (random 1 10) probToilet) (set! cleanliness (max (- cleanliness 3) 0)))
	      (if (< cleanliness 80)
	       (begin (drawDroppings 1) 
		(if (< cleanliness 60)
		 (begin (drawDroppings 2)
		  (if (< cleanliness 40)
		   (begin (drawDroppings 3)
		    (if (< cleanliness 20)
		     (begin (drawDroppings 4)
		      (if (< cleanliness 10) (drawDroppings 5))))))))))
	      ))))
	    
	    ;; play
	    (define (play)
	     (fsmHappiness 'feed-context (list (cons 'play 3)))
	     (fsmSubmissiveness 'feed-context (list (cons 'submission 2))))

	    ;; feed
	    (define (feed food)
	     (cond 
	    ((eq? food 'snack)
	     (fsmHunger 'feed-context (list (cons 'feed 5)))
	     (fsmHappiness 'feed-context (list (cons 'play 1)))
	     (fsmHealth 'feed-context (list (cons 'timer 2))))
	    ((eq? food 'meal)
	     (fsmHunger 'feed-context (list (cons 'feed 10))))))
	    ;; clean
	    (define (clean)
	       (if (< cleanliness 80)
	       (fill (+ x 31) (+ y 30) 30 30 white)
	       (set! probToilet (min (+ probToilet 1) 10)))
	    (set! cleanliness 100))
	  ;; give drugs
	  (define (giveDrugs)
	    (fsmHappiness 'feed-context (list (cons 'giveDrugs 10)))
	    (drawRemoveSickness))
	    ;; dispatch
	  (define (dispatch m)
	   (cond 
	    ((eq? m 'born) (born))
	    ((eq? m 'draw) (draw))
	    ((eq? m 'isAMonster?) #t)
	    ((eq? m 'say) say)
	    ((eq? m 'presentYourself) presentYourself)
      	    ((eq? m 'sleep) (sleep))
	    ((eq? m 'die) (die))
	    ((eq? m 'isAlive?) (isAlive?))
	    ((eq? m 'checkState) (checkState))
	    ((eq? m 'feed) feed)
	    ((eq? m 'play) (play))
	    ((eq? m 'update) (update))
	    ((eq? m 'clean) (clean))
	    ((eq? m 'giveDrugs) (giveDrugs))
	    ((eq? m 'isSleeping?) isSleeping)
	    ((eq? m 'getLife) life)
	    ((eq? m 'getHealth) health)
	    ((eq? m 'getHappiness) happiness)
	    ((eq? m 'getHunger) hunger)
	    ((eq? m 'getAwakeness) awakeness)
	    ((eq? m 'getSubmissiveness) submissiveness)
	    ((eq? m 'getCleanliness) cleanliness)
	    ))
	  dispatch))
   ) port)
(close-output-port port))
